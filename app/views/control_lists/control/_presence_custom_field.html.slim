/ = form.input :target_model, input_html: { 'x-model': 'resource.target_model', 'x-on:change': "resource.target_custom_field_id = ''" }
/ = form.input :target_custom_field_id do
/ 	select.form-control.select.required name="control_list[controls_attributes][0][target_custom_field_id]" x-model="resource.target_custom_field_id" :disabled="!Boolean(resource.target_model) || #{facade.show?}"
/ 		option value=""
/ 		template[x-for="option in #{facade.custom_fields_options}"]
/ 			option :value="option.id" x-text="option.text" x-show="option.resource_type == resource.target_model" :selected="option.id == resource.target_custom_field_id"


div[x-data = "{target_model: '#{form.object.target_model}'}"]
  = form.input :target_model, input_html: { 'x-model': 'target_model' }
  = form.input :target_custom_field_id
  / - form.object.candidate_target_attributes.group_by(&:model_name).each do |model_name, target_attributes|
  /   // If the input is already disabled (read only mode), no javascript handler
  /   - disabled = (form.options[:defaults] || {})[:disabled]
  /   - input_html_options = disabled ? {} : { 'x-bind:disabled': "target_model != '#{model_name}'" }
  /   = form.input :target_attribute, collection: target_attributes.map { |attribute| [ attribute.human_name, attribute.name ] }, wrapper_html: { 'x-show': "target_model == '#{model_name}'" }, input_html: input_html_options